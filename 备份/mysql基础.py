# 数据库
#     修改编码:
#     ALTER TABLE l CONVERT TO
#     CHARACTER set utf8 COLLATE utf8_unicode_ci;
# 概念:
#     1.库：文件夹
#     2.表：文件
#     3.表头：表格的第一行
#     4.表单：除表头以外的东西
#     5.字段：每一列
#     6.记录：文件中一行行的数据
# mySQL的安装（5.6.47版）
# 注意:对于没有data文件夹的版本
#     1.切换到bin目录下（终端输入，回车）:cd 路径
#     2.切换完成后在输入 mysqld --initialize-insecure --user=mysql 回车
# 1. bin 文件下:客户端:mysql.exe,服务端:mysqld.exe
# 环境变量配置（让启动更简单）
# 1.环境变量配置：将bin文件目录添加到系统环境变量中（右键此电脑属性，点击高级系统设置，点击环境变量，在系统变量中找到path，点击path，点击新建。）
# 2.在前期配置mysql时，用终端，并且以管理员身份运行（搜索cmd右键一管理身份运行，桌面快捷方式也可以）
# 启动：
    # 服务端：终端输入mysqld
    # 客户端（链接服务端）：mysql -h 127.0.0.1 -P 3306 -uroot -p   回车（3306mysql的默认端口）
# 简单命令
# 1.mysql中的sql语句是以分号为结束标志的
# 2.show databases;查看库名
# 3.mysql  -uroot -p 本地链接可以简写为这个
# 4.退出客户端:1.quit或exit(可以不加分号)
# 5.终止服务端：taskkill /F /PID 进程pid号  (需要在cmd命令中执行，不能在客户端中执行)
# 5.当输入的命令不对时又不想服务器执行并返回报错信息，可以用\c取消错误命令（x\c;）
# 系统服务制作
#     终端输入：mysqld --install
#     取消：mysqld --remove

# 密码修改
# 语句（终端输入，不是客户端）：mysqladmin -uroot -p 原密码 password 新密码

# 一，sql语句分类
#     DDL:数据定义语言，用于定义数据对象（数据库，表，字段）
#     DML:数据操作语言，用于对数据库中的数据进行增删改
#     DQL:数据查询语言，用来查询数据库中表的记录
#     DCL:数据控制语言，用于创建数据库用户，控制数据库的访问权限
# 1.===============DDL（数据创建）===============
# 1.数据库
#     1.查看所有库名:    show databases;
#     2.查询当前数据库:  select database();
#     3.创建数据库:     create database [if not exists] 数据库名 default charset 字符集 collate 排序规则;  可以简化为（create database 数据库名;）（if not exists 判断不存在才创建）
#     4.删除数据库:     drop database [if exists] 数据库名; 可以简化为（drop database  数据库名;）（if  exists 判断存在才删除）
#     5.使用数据库:     use 数据库名;
#     表
#     1.查询当前数据库所有表(前提是use 数据库):   show tables;
#     2.查询表结构(字段):                           desc 表名;
#     3.查询指定表的建表语句:                   show create table 表名;
#     表的创建:create table 表名(
#         字段1 字段类型,
#         字段2 字段类型,
#         ......
#         )  在最后不用加,
#     4.修改表:
#         1.添加字段:              alter table 表名 add 字段名 类型 [comment 注释] [约束];
#         2.修改数据类型:           alter table 表名 modify 字段名 数据类型;
#         3.修改字段名及数据类型:    alter table 表名 change 原字段 新字段 类型 [comment 注释] [约束];
#         4.删除表:               drop table [if exists] 表名;
#         5.修改表名:              alter table 表名 rename to 新表名;
#         6.删除字段:              alter table 表名 drop 字段名;
#         7.删除指定表，并重新创建该表(即格式化该表,清空数据但不改变表结构):truncate table 表名;
# 2.数据类型

# ===============1.数值类型============================

#  tinyint         1 Bytes    小整数值(小于255)
#  smallint        2 Bytes    大整数值(小于6万多)
#  mediumint       3 Bytes    大整数值(小于1600万多)
#  int/integer     4 Bytes    大整数值(小于42亿多)
#  bigint          8 Bytes    极大整数值(2千京以下,20位数)
#  float           4 Bytes    单精度浮点数值
#  double          8 Bytes    双精度浮点数值
#  decimal(x,y)    x>y则为x+2  小数值         （x为总长度,y为小数精度）

# ===================2.字符串类型======================

#  char	           0-255 bytes	              定长字符串
#  varchar	       0-65535 bytes	          变长字符串
#  tinyblob	       0-255 bytes	              不超过 255 个字符的二进制字符串
#  tinytext	       0-255 bytes	              短文本字符串
#  blob	           0-65 535 bytes	          二进制形式的长文本数据
#  text	           0-65 535 bytes	          长文本数据
#  mediumblob	   0-16 777 215 bytes	      二进制形式的中等长度文本数据
#  mediumtext	   0-16 777 215 bytes	      中等长度文本数据
#  longblob	       0-4 294 967 295 bytes	  二进制形式的极大文本数据
#  longtext	       0-4 294 967 295 bytes	  极大文本数据
# 注带blob描述二进制数据(非常少用)，带text描述文本数据的

# =================3.日期时间类型============================
#  date	         3bytes	   	YYYY-MM-DD	          日期值
#  time	         3bytes	   	HH:MM:SS	          时间值或持续时间
#  year  	     1bytes	   	YYYY	              年份值
#  datetime	     8bytes	   	YYYY-MM-DD hh:mm:ss	  混合日期和时间值
#  timestamp	4bytes                            混合日期和时间值，时间戳
# 2.===============DML（数据修改）===========
# #     1.添加数据(添加一行):insert
#         1.给指定字段添加数据:insert into 表名 （字段1,...） values （值1,...);
#         2.给全部字段添加数据:insert into 表名 values (值1,...);
#         3.批量添加:
#                 1.insert into 表名 （字段1,...） values （值1,...),（值1,...)...;
#                 2.insert into 表名 values (值1,...),（值1,...)...;
#     2.修改数据（修改某一个字段）:update
#         1.update 表名 set 字段名1=值1,...[where 条件];  没有条件则为修改整张表的数据
#     3.删除数据（行）:delete
#         1.delete from 表名 [where 条件];  没有条件则删除所有数据，（只能对整行进行删）
# 3.============DQL（数据查询）==============
# 语法:select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后条件列表 order by 排序字段列表 limit 分页参数
# 一，基本查询
# 1.查询多个字段:select 字段1,...form 表名;  或 select * form 表名;
# 2.设置别名(了解，展示数据时，原名称会被改为别名):select 字段1 [as 别名1],...form 表名;  as可以省略，别名最好为字符串
# 3.去重（显示时不会显示重复项）:select distinct 字段列表 form 表名;  （就是多加了distinct 其他多可以和上面的一样）
# 二，条件查询
#     1.select 字段列表 from 表名列表 where 条件列表
# 条件可选格式:
#     一，比较运算
#     1.              >,>=,>,<=,=,
#     2.              <>or!=
#     3.区间:          between 最小值 and 最大值
#     4.列表中的:       in(...)
#     5.模糊匹配_或%:   like 占位符（_或%）  _:匹配单个字符 %:匹配多个字符  where name like 占位符
#     6.判断是否为null: is null
#     二，逻辑运算符
#     1.多个条件:and或&&
#     2.或者:or或||
#     3.非:not 或！
# 聚合函数（对列操作）(不对null值进行计算)
# 语法:select 聚合函数（字段列表） from 表名;
#     1.统计个数:     count     统计字段:select count(*) from 表名;
#     2.最大最小值:   max,min
#     3.平均值:      avg
#     4.求和:        sum
# 三，分组查询:
#     语法:select 字段列表[需要展示的字段] from 表名 [where 条件列表] group by 分组字段列表 [having 分组后条件列表];
#     字段列表[需要展示的字段]，分组后条件列表必须在分组字段列表中（select name,总分 from l where 性别='男' group by 总分,数学 having 总分>300 and 数学>80）
#     注意1:只有where成立的数据才会被having条件使用,where不能对聚合函数判断，having可以。
#     注意2:分组后，查询的字段一般为聚合函数和分组字段。
# 四，排序查询
# 语法:select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方式,...;
#       1.排序方式:1.升序(默认):asc，2.降序:desc
#       2.多字段排序，如果第一个相同再按第二个排序
# 五，分页查询(limit)（是数据库的方言，不同数据库有不同的实现）
#     语法:select 字段列表 from 表名 limit 起始索引,查询记录数;
#     起始索引（从0开始）=（查询页码-1）*每页显示记录数。如果是第一页可以省略起始索引。
# 六，DQL 执行顺序:from>where>group by>having>select>order by>limit
#     4.DCL(数据库控制语言，用户权限)
#     1.查询用户: select * from uer; (用户数据存放在mysql库中的uer表中，先use mysql)
#     2.创建用户:create user '用户名'@'主机名' identified by '密码';  # @两边不能有空格
#     3.修改用户密码:alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';
#           5.x版本用这个:set password for '用户名'@'主机名' =password ('新密码');
#     4.删除用户:drop user '用户名'@'主机名';
#     当主机名为localhost:只能通过本机连接，为%时可以在任意主机访问
#     权限控制:
#         1.所有权限:           all或all privieges
#         2.查询数据:           select
#         3.插入数据:           insert
#         4.修改数据:           update
#         5.删除数据:           delete
#         6.修改表:             alter
#         7.删除数据库/表/视窗:   drop
#         8.创建数据库/表:       create
#     1.查询权限:show grants for '用户名'@'主机名';
#     2.授予权限:grant 权限列表[权限] on 数据库名.表名 to '用户名'@'主机名';       数据库名.表名=*.*时为全部
#     3.撤销权限:revoke 权限列表[权限]  on 数据库名.表名 from '用户名'@'主机名';    数据库名.表名=*.*时为全部
# 4.===========函数=================
# 1.字符串函数（可以嵌套）
# 语法:可以嵌入其他语法中或(select+函数)
#     1.字符串拼接（）:(x1,...)
#     2.小写大写:lower(ser) upper(str)
#     3.左填充:lpad(字符串,长度,填充符)
#     4.左填充:rpad(字符串,长度,填充符)
#     5.去除空格:trim(str)
#     6.切片(索引从1开始):substring(x,y,len)
# 2.数值函数
#     1.向上取整:                  ceil()  1.5取整为2
#     2.向下取整:                  floor()
#     3.x/y的模(取余):             mod(x,y)
#     4.返回0-1之间的随机数(无参数):  rand()
#     5.四舍五入(y为保留位数):       round(x,y)
# 3.日期函数
#     1.返回当前日期:                  curdate()
#     2.返回当前时间:                  curtime()
#     3.返回当前日期和时间:             now()
#     4.返回指定x的年份:               year(x)
#     5.返回指定x的月份:               month(x)
#     6.返回指定x的日期:               day(x)
#     7.返回一个加上时间间隔x后的时间: date_add(x,interval x 单位)
#     8.返回x-y的天数:                 datediff(x,y)
# 4.流程函数
#     1.if(条件,成立返回值,不成立返回值)
#     2.x1不为空返回x1,否者返回x2:        ifnull(x1,x2)
#     3.x成立返回y，否者返回在:           case when [x] then [y]...else [z] end
#     4.当x1等于x2返回y否者返回z:         case [x1] when [x2] then [y]... else [z] end
# 5.============约束==================
# 1.非空约束(字段数据不能null):not null
# 2.唯一约束(字段数据是唯一的，不重复):unique
# 3.主键约束(主键是一行是数据的唯一标识，非空且唯一):primary key
# 4.默认约束(保存数据时，不指定该字段的指，采用默认值):default
# 5.外键约束(在两张表之间建立连接):foreign key
# 6.自增约束:auto_increment
# 7.检查约束:check(条件)
# 约束作用于字段上，创建表/修改表的时候可以添加约束(多个约束之间使用空格分开)
# 8.添加外键
#     1.创建表时：create table 表名(字段 类型...constraint 外键名称 foreign key(外键字段名) references 主表(字段名))
#     2.对现有表添加：alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(字段名)
#     常见报错:表名重复、主键名字在全数据库范围内不是唯一的、外键是否是全局唯一、关联数据类型是否相同
#     3.删除外键：alter table 表名 drop foreign key 外键名
# 9.外键约束的删除与更新行为
#     语法:(在更新时和删除时做的约束)
#         alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(字段名) on update 约束 on delete 约束
#     1.no action:  当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致)（默认的）
#     2.restrict:   当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NOACTION一致)（默认的）
#     3.cascade:    级联   当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录
#     4.set null:   当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null(这就要求该外键允许取null)
# 七，多表查询
#     多表关系:一对多（多对一）、多对多、一对一
# 1.一对多（多对一）:在多的一方建立外键，关联一的一方的主键
# 2.多对多:建立一张至少有两个外键的中间表，分别关联两方主键
# 3.一对一:在任意一方设置外键，关联另一方的主键，并设置外键约束为unique
#     多表查询分类
#     1.连接查询
#         内连接：交集部分
#         外连接
#             左外链接：左表（1）+交集部分
#             右外连接：右表（2）+交集部分
#         自连接：当前表与自身的连接查询，自连接必须使用表别名
#     2.子查询：
# 4.多表查询：
#     1.内连接：
#         1.隐性内连接语法：
#             select 字段列表 from 表1,表2 where 条件             # 表1.字段，表2.字段(起别名更方便)
#         2.显性内连接：
#             select 字段列表 from 表1 inner join 表2 on 连接条件     # 同隐性内连接条件
#     2.外连接
#         1.左外连接（用多）：
#             select 字段列表 from 表1 left outer join 表2 on 条件    # outer可以没有
#         2.右外连接：
#             select 字段列表 from 表1 right outer join 表2 on 条件
#         3.自连接（可以是内连接、外连接）：
#             select 字段列表 from 表1 as 别名1 join 表1 as 别名2 on 条件  # 其中一个示例（外连接同上，要起别名）
#         4.联合查询(查询的字段数及字段类型要一致)：
#             select 字段列表 from 表1...
#             union [all]    # 有all：直接合并，没有all：会去重
#             select 字段列表 from 表2...；
#     3.子查询（嵌套查询，可以多层嵌套）：
#         select * from 表 where x=(子查询（同正常的查询）)
#     4.查询结果的不同分为：
#         1.标量子查询：返回单个值，大多使用数学运算符(<,>,=<,>=,=)
#             select cj.姓名,cj.总分 from cj where from_id=(select id from from_name where from_name.from_name='柳州') ;
#         2.列子查询：返回一列，（in，not in,any(子查询放回的列表有一个满足即可),some（同any）,all(必须全满足)）
# select cj.姓名,cj.from_id from cj where from_id in (select id from from_name where from_name='北京'or from_name='融水');
#         3.行子查询：返回一行(可以多列) =，<>(不等于)，in，not in
#             select * from cj where (班级,语文)=(select 班级,语文 from cj where 姓名='赵瑜梦');
#         4.表子查询：返回多行多列 多用in
#             select * from 表 where (x,y) in (子查询结果应返回x,y，该结果为多行多列);
#         5.可以放在select、from、where 之后
# 八，事务
#     1.语法
#         1.查看事务提交方式：select @@autocommit;   （1为默认提交，0为手动提交）
#         2.修改提交方式：set @@autocommit=0
#         3.开启事务：begin;
#         4.提交事务：commit;  （所有操作成功再提交）
#         5.回滚事务：rollback;  (发生异常执行)
#     2.事务的四大特性
#         1.原子性：事务是最小的操作单元，要么全部成功，要么全部失败。
#         2.一致性：事务完成时，必须使所有的数据都保持一致。
#         3.隔离性：数据库系统提供隔离机制，使事务在不受外部并发操作影响的环境下运行。
#         4.持久性：事务一旦提交或回滚，它对数据库数据的改变将是永久的。
#     3.并发事务问题
#         1.脏读：一个事务读到另一个事务还没有提交的数据。
#         2.不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。
#         3.幻读：一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在。
#     4.事务的隔离级别
#         1.read uncommitted：读未提交，所有并发问题都会出现
#         2.read committed：读已提交，解决了脏读
#         3.repeatable read：可重复读(默认的)，解决了脏读、不可重复读
#         4.serializable：串行化，解决了脏读、不可重复读、幻读
#         5.查看事务的隔离级别：select @@tx_isolation;(select @@transaction_isolation;8.0以上版本)
#         6.设置事务隔离级别session(当前会话窗口有效)global(所有会话窗口有效)：set session/global transaction isolation level 级别
# 九，存储引擎
#         1.建表时指定存储引擎：create table 表（。。。）engine=储存引擎;
#         2.查看数据库支持的引擎：show engine;
# 十，索引
#     1.索引结构
#         1.B+Tree索引，重点：         最常见的索引类型，大部分引擎都支持B+树索引
#         2.Hash索引：           底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询
#         3.R-tree(空间索引)：    空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
#         4.Full-text(全文索引)： 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,ES
#     2.索引分类：
#         1.primary： 主键索引 针对于表中主键创建的索引 默认自动创建             只能有一个
#         2.unique：  唯一索引 避免同一个表中某数据列中的值重复                 可以有多个
#         3.无关键字：  常规索引 快速定位特定数据                             可以有多个
#         4.fulltext：全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个
#     3.innoDB引擎中根据索引的储存形势分类
#         1.聚集索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据   必须有，而且只有一个
#         2.二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键   可以存在多个
#     4.语法：
#         1.创建索引：create [索引类型] index 索引名称 on 表名(索引字段名...);   [索引类型]不指定，即为常规索引
#         2.查询索引：show index from 表名;
#         3.删除索引：drop index 索引名称 on 表;
#     5.sql性能分析
#         1.查询当前数据库操作频次：show [session/global] status like 'com_______';
#     6.索引的使用规则
#         1.最左前缀法则：对于联合索引，查询从索引的最左列开始，并且不跳过索引中的列()
#         2.范围查询：出现范围查询(<,>)，范围查询右侧的列索引失效。如:age>12 and set=0，set将失效，如何规避：业务允许情况下使用>=,=<
#         3.不要在索引列上进行运算操作，索引将失效。
#         4.查询时字符串不加引号，索引将失效。
#         5.如果进行头部模糊(头部已知)匹配，索引将失效。
#         6.用or分割的开的条件，如果or前条件中的列有索引，后面的列中没有索引，那涉及的索引都不会被用到。
#         7.数据分布影响：mysql评估使用索引比全表更慢，就不会用到索引。
#     7.索引的设计原则(需建立索引的)
#         1.数据量较大(百万条数据)，且查询比较频繁的表
#         2.常作为查询条件(where)、排序(order by)、分组(group by)的字段
#         3.尽量选择区分度高(用户的身份证...)的列做为索引，尽量建立唯一索引，区分多越高，索引的效率就越高。
#         4.如果是长度较长的字符串字段，推荐使用前缀索引。
#         5.尽量使用联合索引，查询时联合索引大多数情况下会覆盖单列索引，节省储存空间，避免回表，提高查询效率。
#         6.索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率。
#         7.如果索引列不能为null值，应在建表时使用非空约束来约束它，以便优化器能更好的确定那个索引用于查询最有效
# 十一，视图（是一张虚拟存在的表）
#     1.创建视图：create view 视图名称[列名列表] as select语句 [with check option];  with...不符合视图条件的数据不会被插入
#     2.查询创建视图的语句:show create view 视图名称;
#     3.查看视图(同表一样)：select * from 视图名称;
#     4.修改视图一：create or replace view 视图名称[列名列表] as select语句;  select语句与原视图不同即可
#     5.修改视图二:alter view 视图名称[列名列表] as select语句;
#     6.删除视图:drop view [if exists] 视图名称;
#     7.在视图插入数据时，实际上插入到那个表中。
#     8.视图检查选项
#         1.当使用with [local]check option子句创建视图时，mysql会通过视图检查正在更改的每个行，例如插入、更新、删除、以使其符合视图的定
#         义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：
#         cascaded和local，默认值为cascaded(可以不加)。有local的视图会递归去检查有条件的被引用到的所有视图。
#     9.视图的更新
#         可更新的试图:视图中的行必须与基础表中的行存在一对一的关系。存在以下条件试图不可更新。
#         1.聚合函数或窗口函数：sum max min count 等
#         2.distinct
#         3.group by
#         4.having
#         5.union、union all
#     10.视图作用
#         1.简单：使用户操作简单
#         2.安全：数据库无法授权字段，通过视图可以达到目的
#         3.数据独立：视图可以屏蔽实际表的数据变化
#         4.大量的select语句可以封装到视图中，方便查询。
# 十二，存储过程
#     存储过程:存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，
#     对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。
#     1.特点：封装、复用、可以接受参数、可以返回数据、减少网络交互，提升效率。
#     2.创建存储过程：create procedure 存储过程名称([参数列表]) begin sql语句 end;
#     3.调用存储过程：call 存储过程名称([参数]);
#     4.查询指定数据库的储存过程及状态信息：select * from information_schema.ROUTINES where ROUTINE_SCHEMA='数据库';
#     5.查询某个存储过程的定义语句：show create procedure 存储过程名称;
#     6.删除储存过程：drop procedure 储存过程名称;
#     7.设置sql语句结束符(在命令行中)：delimiter 结束符
#     8.变量
#         1.系统变量(属于服务器层面):全集变量(global) 会话变量(session)
#         2.查看系统变量： (不指定默认为session)
#             1.查看所有系统变量：show [session或global] variables;
#             2.模糊匹配：show [session或global] variables like '匹配符';
#             3.查看指定变量：select @@[session或global.]系统变量名;     这个好点：select @@系统变量名;
#             4.设置系统变量
#                 1.set [session或global] 系统变量名=值
#                 2.set @@[session或global] 系统变量名=值
#         3.用户自定义变量(不需要提前声明，直接赋值即可)：
#             1.赋值
#                 1.通过set赋值(可以一次性多个，用逗号隔开)
#                     1.set @自定义变量=值;
#                     2.set @自定义变量:=值;
#                 2.通过select赋值
#                     1.select @自定义变量:=值;
#                     2.select 字段名(结果为单个东西就行) into @自定义变量 from 表名;
#             2.使用：select @自定义变量;
#         4.局部变量(放在begin与end之间)
#             1.声明局部变量：declare 变量名 类型[default 默认值]   类型就是字段类型
#             2.赋值
#                 1.set 变量名=值;
#                 2.set 变量名:=值;
#                 3.select 字段名(结果为单个东西就行) into 变量名 from 表名;

#     9.if判断(放在储存过程之内)
#         语法：
#         if 条件 then
#             ...;
#         elseif 条件 then
#             ...;
#         else
#             ...;
#         end if;
#     10.参数
#         1.类型
#             1.in:输入(默认的)
#             2.out：输出
#             3.inout：输入输出
#         2.用法
#             create peocedure 存储过程名称(输入输出类型 参数名 参数类型) begin sql语句 end;
#         3.案例
#         示例1(接收需要定义赋值变量)：
#         create procedure sd(in x int ,out y char(10))
#         begin
#              if x>10 then
#                 set y='大于10';
#              else
#                 set y='很大';
#              end if;
#         end;
#         call sd(11,@o);  #@o赋值变量，用于接收返回值
#         select @o;
#         示例2(输入输出需提前赋值)：
#         create procedure sd(inout x int)
#         begin
#              if x>10 then
#                 set x=x*2;
#              else
#                 set x=x*0.5;
#              end if;
#         end;
#         set @o=20;
#         call sd(@o);  #@o赋值变量，用于接收返回值
#         select @o;
#     12.case流程
#         语法：
#         case
#             when 条件表达式 then
#                 ...;
#             ...
#             else
#                 ...;
#         end case;
#     13.while循环
#         语法：
#         while 条件 do
#             sql语句;
#         end while;
#         示例：
#         create procedure sd(in y int)
#         begin
#             declare x int default 0;
#             while y>0 do
#                 set x=x+y;
#                 set y=y-1;
#             end while;
#             select x;
#         end;
#         call sd(100);
#         14.repeat循环（满足条件会退出）
#             语法：
#             repeat
#                 sql语句
#             until 条件
#             end repeat;
#         15.loop循环
#             介绍：用于循环，如果不在sql语句中增加退出条件，就是死循环，可以配合以下语句使用。
#             1.leave:像break。
#             2.iterate:像continue
#             语法：
#                 loop
#                     sql语句
#                 end loop;
#         16.游标
#             游标：游标类似于列表，储存查询结果的数据级，在储存过程和函数中可以遍历游标中的数据(游标遍历完会报错)。
#             1.声明游标:declare 游标名称 cursor for 查询语句;   #注意先声明变量再声明游标
#             2.打开游标:open 游标名称;
#             3.获取游标数据:fetch 游标名称 into 变量;  #可复制多个，有逗号隔开。配合循环使用
#             4.关闭游标:close 游标名称;
#         17.条件处理程序(和声明的变量在一起)
#             语法：
#             declare 条件处理程序类型 handler for 条件列表...其他sql语句;
#             1.条件处理程序类型
#                 1.continue：继续执行程序
#                 2.exit:终止程序
#             2.条件
#                 1.sqlstate '状态码'  #状态码：报错时最前面的数字
#                 2.sqlwarning:代表所有以01开头的状态码
#                 3.not found:代表所有以02开头的状态码
#                 4.sqlexception:代表所有没有被2.3所捕捉的状态码
#         18.存储函数：有返回值的存储过程，参数只能是in类型，不用指定，(少用，它能实现的，存储过程也能。)
#             语法：
#             create function 存储函数名称([参数列表])
#             returns 数据类型 [x]
#             begin
#                 sql语句
#                 return...;
#             end;
#             2.x说明(可以写)
#                 1.deterministic:相同的输入参数总是产生相同的结果。
#                 2.no sql:不包含sql语句。
#                 3.reads sql data:包含读取数据的语句，但不包含写入数据的语句。
#             3.删除存储函数：drop function 函数名;
#             4.示例：
#                 create function func(n int)
#                 returns int
#                 begin
#                     declare t int default 0;
#                     while n>0 do
#                         set t=t+n;
#                         set n=n-1;
#                     end while;
#                     return t;
#                 end;
#                 select func(100);
#                 drop function func;
# 十三，触发器
#     1.触发器:是与表有关的数据库对象，在执行插入、更新、删除之前或之后，出发并执行触发器中定义的sql语句集合。只支持航机并发，不支持sql语句级触发。
#     2.作用：服务端确保数据的完整性，日志记录，数据校验等。
#     3.触发器类型
#         1.insert触发器:new表示将要或者已经新增的数据。
#         2.update触发器：old表示修改之前的数据，new表示将要或者已经修改后的数据。
#         3.delete触发器：lod表示将要或者已经删除的数据。
#     4.创建触发器：
#         create trigger 触发器名称
#         before/after insert/update/delete  #之前或之后，数据修改类型
#         on 表名 for each row  #for each row代表行级触发器
#         begin
#             相关语句;
#         end;
#     5.查看触发器:show triggers;
#     6.删除触发器：drop trigger [数据库.]触发器名称  #不指定数据库，默认为当前数据库

# =====================PHP========================
# 1.php可以嵌入文档任何位置
# 2.语法：PHP脚本以<?php开始，以?>结束。PHP中的每个代码行都必须以分号结束
# 示例：
# <?php
# // php代码;
# ?>
# 2.输出：
#     1.echo:可以输出一个或多个字符串
#     2.print:只允许输出一个字符串，返回值总为 1
#     3.echo输出的速度比print快，echo没有返回值，print有返回值1。
#     4.字符串可以包含HTML标签：示例：echo"<h2>PHP很有趣!</h2>";
# 3.注释：
#     1.单行注释：//或#
#     2.多行注释：/*内容*/
# 3.变量：使用$定义变量
#     1.语法：$变量名=值
#     2.规则
#         1.以$开始，后面跟着变量名
#         2.必须以字母或者下划线字符开始
#         3.只能包含字母、数字以及下划线
#         4.不能包含空格
#         5.区分大小写
#     3.变量作用域
#         1.种类
#             1.local：
#             2.global:全局变量声明（同python一样，在函数内部声明,可同时声明多个，用逗号隔开）
#             3.static:函数完成时，它的所有变量都会被删除,当希望某个局部变量不要被删除,需要在第一次声明变量时使用static
#                 注意：每次调用该函数时，该变量将会保留着函数前一次被调用时的值。，变量仍然是函数的局部变量。
#             4.parameter：
# 4.EOF(heredoc)：
#     1.语法：
#     <<<EOF
#         代码1
#         ...
#     EOF; #结束必须独占一行
#     2.使用规则：
#         1. 必须后接分号
#         2. EOF可以用任意其它字符代替，只需保证结束标识与开始标识一致。
#         3. 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。
#         4. 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。
#         5. 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法
#         6.可以被赋值。
# 5.数据类型
#     1.字符串：同python
#     2.整型：同python
#     3.浮点型：同python
#     4.布尔类型：同python
#     5.对象：比较复杂（类似python）
#     6.null值：变量=null
#     7.资源类型：略
# 6.比较：
#     1.松散比较==：只比较值，不比较类型
#     2.严格比较===：比较值，也比较类型
# 7.常量（是全局的）：
#     1.定义常量：使用define()函数
#     语法:define("常量名",值)
# 8.字符串（同python）
#     1.:类似与python中的字符串+
#     2.strlen()：长度
#     3.strpos()：查找，（对象,查找的）
# 9.流程控制：
#     1.if判断
#     语法：
#         if(条件)
#         {
#         代码;
#         }
#         elseif(条件)
#         {
#         代码;
#         }
#         else
#         {
#         代码;
#         }
#     2.switch判断：
#     语法;
#     switch(条件x通常是一个变量)
#     {
#     case 值1  #如果条件x=值1执行
#         代码;
#         break;
#     case 值2  #如果条件x=值1执行
#         代码;
#         break;
#     default  #都不成立执行
#         代码；
#     }
# 10.数组
#     1.创建数组：array()
#     2.种类
#         1.数值数组：带有数字ID(索引)键的数组  array("Volvo","BMW","Toyota");
#         2.关联数组：带有指定的键的数组，每个键关联一个值  array("Peter"=>"35","Ben"=>"37","Joe"=>"43");
#         3.多维数组：包含一个或多个数组的数组
#     3.count()：获取数组长度
# 超级全局变量
#     1.$GLOBALS:是一个超级全局变量组，在全部作用域中都可以访问,是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。
#     2.$_SERVER: 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组(类似对象)
#     3.$_REQUEST：接受表单数据。$name = htmlspecialchars($_REQUEST['表单名字']);  echo $name;
#     4.$_POST：广泛应用于收集表单数据，在HTML form标签的指定该属性："method="post"   示例;$name = $_POST['表单名'];
#     5.$_GET：同样被广泛应用于收集表单数据，在HTML form标签的指定该属性："method="get"
#     6.$_FILES：
#     7.$_ENV：
#     8.$_COOKIE：
#     9.$_SESSION：
# ====================while 循环：重复执行代码块，直到指定的条件不成立。=====================
# 1.语法
# while (条件)
# {
#     要执行的代码;
# }
# 2.do...while循环：语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。
# do
# {
#     要执行的代码;
# }
# while (条件);
# =================for循环=================
# 1.语法：
# for (初始值; 条件; 增量)
# {
#     要执行的代码;
# }
# 初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。
# 条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。
# 增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。
# ++：加一
# ============foreach 循环：用于遍历数组====================
# 1.语法：
# foreach ($array as $value)
# {
#     要执行代码;
# }
# 每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。
# 2.语法
# foreach ($array as $key => $value)
# {
#     要执行代码;
# }
# 每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。
# =====================函数=====================
# 1.语法(定义)，调用（像python）,参数同python（定义参数要加$）
# function 函数名([参数])
# {
#     要执行的代码;
#     return 返回值;
# }
# ====================================================
# ========================表单=========================
# ====================================================
# 十三.表单标签(与用户交互，用于收集用户信息)
#     1.结构:表单域（整个表单），表单控件（表单元素，交互区），提示信息（表单文本）
#     2.表单域（规定返回服务器的信息的区域）:<form action="url地址" method="提交方式" name="表单域名称">表单元素控件</form>
#         1.action= 服务器程序的url地址
#         2.method=   get或post
#     3.表单控件（单标签)（以下包含在<form></form>中）
#         1.输入表单元素:<input type="属性值" name（可选）="表单元素名字" value（可选）="提示内容"/>
#             1.属性值type：
#                 1.text:      定义单行的输入字段，用户可以输入，默认宽度为20
#                 2.password:  定义一个密码框，用户看不到输入的密码
#                 3.radio:       定义一个单选框（不可取消）
#                 4.checkbox:  定义一个复选框（可取消）
#                 5.submit:    定义提交按钮，提交按钮会把表单数据提交给服务器（改变文本需添加value="文本"）
#                 6.reset:     定义重置按钮，点击将重置页面输入数据（改变文本需添加value="文本"）
#                 7.button:    定义点击按钮（用于启动脚本，如获取验证码）
#                 8.file:      定义上传文件按钮
#             2.属性name:                （当定义名字相同的两个表单元素，选择是只会被选择一个）注：单选框或复选框要有相同的name值
#             3.属性value:                用户输入框内的提示信息 或 在复选框中定义返回服务器的value值
#             4.属性checked="checked":    页面首次加载input会被默认选中
#             5.属性maxlength（了解）:      规定输入字符的长度
#         2.label标签:（用于快速定位光标）
#             1.语法:<label for="名字">提示信息</label><input.....id="名字"/>   注意:for 要与id的内容相同
#         2.下拉表单元素（下拉菜单）:
#            1.语法:<select><option>文本1</option><option>文本2</option></select>   <option>中可以定义selected="selected" 即该项为默认选中项
#         3.文本域元素(用于定义多行的文本输入):
#             1.语法:<textarea>提示内容</textarea>
#                 1.属性cols="":每行最多能写的字数(了解)
#                 1.属性rows="":最多能显示多少行(了解)
# =======================================================
# =======================================================
# ===================php+数据库=================
# 1.连接mysql
# MySQLi - 面向过程==============
# 1.创建连接：$conn(变量) =mysql_connect("服务器名称(可以提前定义变量)", "用户名", "用户密码");
# 2.检测连接
# if (!$conn)
#     {
#     die("Connection failed: " . mysqli_connect_error());
# }
# echo "连接成功";
# 3.关闭:mysqli_close($conn);
# 4.创建数据库
# $sql = "CREATE DATABASE myDB";
# mysqli_query($conn(连接语句), $sql(创建数据库语句)));
# 5.选择数据库：mysql_select_db("数据库名", 连接语句)
# 6.mysqli_query(连接语句, sql语句)

# 补充
# 1.修改字段默认值：alter table 表名 alter column 字段名 set default 默认值;
# 2.create user:创建、修改、删除、用户的权限
# 3.授权最后加 with grant option:表示用户可以将自己的权限授予给别人。
# 4.授权字段时：权限(授权字段列表)
# 5.没有密码的用户可以不用加identified...
# 6.names：字符集
# 7.对已有字段添加唯一约束：alter table 表名 constraint  unique(字段名);
# 8.创建按字段排序的索引：create index 索引名称 on 表(字段名 desc);  desc:降序
# 事件：
# 1.创建事件：create event 事件名称 on schedule 时间 do 任何sql语句    时间:evenry 1 day    week 7 day
# 9.
# php 函数：
# 1.mysq_affected_rows(sql):返回前一次 sql 操作所影响的记录行数
# 2.mysq_close(连接)	关闭先前打开的数据库连接。
# 3.mysq_query()	执行某个针对数据库的查询。
# 4.mysq_connect()	打开一个到 MySQL 服务器的新的链接。
# 5. mysq_free_result(连接) 释放内存

# /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
# ================数据库三级================
# ================数据库三级================
# /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
# 第一章：数据库基本概念
# 1.数据：是数据库中储存的基本对象，是描述事物的符号序列
# 2.数据库（DB）：
# 3.数据库系统(DBS):
# 4.数据库管理系统(DBMS)：
# 5.数据库应用系统(DBAS):组成(数据库系统，应用软件，应用界面)
# 6.软件工程
#     1.由方法，工具，过程三部分组成
# 7.数据库应用系统生命周期模型(瀑布模型)
#     1.生命周期
#         1.项目规划
#         2.需求分析
#         3.系统设计
#         4.实现与部署
#         5.运行管理与维护
#     2.三条设计主线
#         1.数据组织与储存设计
#         2.数据访问与处理设计
#         3.应用设计
#     3.根据数据库三级结构可分为
#         1.概念设计
#         2.逻辑设计
#         3.物理设计
# 8.开发详细介绍
# 1.规划与分析阶段
#     1.系统规划与定义：确定任务目标，范围，边界，用户视图
#     2.可行性分析：技术经济操作可行性分析及开发方案选择
#     3.项目规划：项目团队，环境，活动，成本，预算，进度计划
# 2.需求分析（对用户的需求分析）
#     1.需求获取：面谈，实地观察，问卷调查，查阅资料
#     2.需求分析
#     3.编写需求规格说明书（成果）
#     4.需求评审
# 3.系统设计
#     1.概念设计：数据库概念模型设计，系统总体设计
#     2.逻辑设计：数据库逻辑结构设计，应用程序概要设计，数据库事务概要设计
#     3.物理设计：数据库物理结构设计，数据库事务详细设计，用程序详细设计
# 4.实现与部署
#     1.建立数据库结构
#     2.数据加载
#     3.事务和应用程序的编码及测试
#     4.系统集成
#     5.测试与运行
#     6.系统部署
# 5.运行管理与维护
#     1.日常维护
#     2.系统监控与分析
#     3.系统性能优化调整
#     4.系统升级
# 第二章：需求分析
# 1.需求分析方法
#     1.结构化分析与建模方法
#         1.DFD：数据流图
#         元素结构
#             1.箭头：数据流
#             2.圆或椭圆（有一横的长方框）：加工
#             3.双杠（有一竖的长方框）：数据储存
#             4.方框(长方框)：数据源点或终点(实体)
#         规则
#             1.父图描述过的数据流必须在相应子图出现
#             2.一个处理至少有一个输入和输出流
#             3.一个储存必定有流入的数据流与流出的数据流
#             4.一个数据流至少有一端是处理框
#             5.表述的信息是全面，完整，正确，一致的
#         2.IDEF
#     2.面向对象分析与建模方法
#         1.UML
# 第三章：数据库设计
# 概念设计：数据库设计的核心环节，独立于DBMS的概念模型
#     1..目标
#         1.数据范围
#         2.数据属性特征
#         3.数据之间的关系
#         4.描述定义数据约束
#         5.数据的安全需求
#         6.数据处理需求（事务）
#         7.数据库模式
#     2..结果
#         1.概念模型(ER图)
#             1.元素
#                 1.长方形：实体(集)
#                 2.菱形：联系
#                 3.椭圆：属性，带下划线的属性名叫主键
#             2.介绍
#                 1.实体：可以区分的东西
#                 2.实体集：同类型的实体的集合
#                 3.属性：实体所具有的一个或多个特征，其范围叫域
#                 4.码：主键，唯一标识
#                 5.联系：也可以有属性
#                 6.联系集：同类型的联系的集合
#         2.概念设计说明书
# 2.逻辑设计
# 逻辑设计：将概念模型转化为DBMS支持的数据模型(关系模型等)
#     1.补充
#         1.关系模型：最流行的数据模型，核心是二维表格
#         2.关系型数据库设计的核心是：关系模式的设计
#         3.数据依赖（类型大多为）：
#             1.函数依赖：一个属性依赖与另一个属性
#                 1.完全函数依赖：x依赖与y，且有任何x属于y，x可以是多个属性
#                 2.传递函数依赖：x依赖与y，y依赖于z，有x依赖于z
#             2.多值依赖：一个属性依赖与另外几个属性
#         4.候选码，主键（码），外键（码）：
#             1.候选码：可以作为主键字段（可以有多个）
#             2.主键
#             3.外键
#         5.数据规范化(主要由关系范式完成)
#             1.1NF：所有属性不可再分
#             2.2NF：符合第一范式，且每个非主属性完全函数依赖于主键
#             3.3NF：符合第二范式，且每个非主属性不传递依赖于主键
#     2.联系转化为关系模型
#         1.一对一
#             1.转化为一个独立的关系模型
#             2.合并一端（创建外键，有两个方向，对应两个模型）
#         2.一对多
#             1.转化为一个独立的关系模型
#             2.与多一端的合并
#         3.多对多
#             1.转化为一个独立的关系模型
#         4.三个及三个以上的实体间的联系
#             1.转化为一个独立的关系模型
# 3.物理设计
# 物理设计：设计数据库的存储结构和物理实现方法
# 1.数据库的物理结构：物理设备上的存储结构与存取方法



# 佛脚
# 事务规范：事务名称、事务描述、事务所访问的数据项、事务用户
# IDEF1X侧重分析、抽象和概括应用领域中的数据需求，被称为数据建模方法
# 数据库应用系统的实施工作包括创建数据库、装载数据、编写与调试应用程序、数据库试运行
# 数据处理需求分析结果也可以表示为事务规范。事务规范包括事务名称、事务描述、事务所访问的数据项、事务用户。
# 数据库应用系统日常维护包括：备份与恢复、完整性维护、安全性维护、存储空间管理和并发控制
